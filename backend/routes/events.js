"use strict";\n\n// Events API router\n// GET /api/events supports filtering, sorting, and pagination\n// Query params:\n// - page (number, default 1)\n// - limit (number, default 4)\n// - sortBy ("date" | "time" | "popularity", default "date")\n// - sortOrder ("asc" | "desc", default "desc" for newest first)\n// - date (YYYY-MM-DD exact match)\n// - dateFrom/dateTo (YYYY-MM-DD range)\n// - time (HH:mm exact match)\n// - timeFrom/timeTo (HH:mm range)\n// - type (string contains, case-insensitive)\n// - place (string contains, case-insensitive)\n// - minPopularity/maxPopularity (number range)\n\nconst path = require("path");\nconst fs = require("fs");\nconst express = require("express");\n\nconst router = express.Router();\n\nconst DATA_PATH = path.join(__dirname, "../data/events.json");\n\nfunction loadEvents() {\n  // Read fresh data every request to simplify sample project\n  const raw = fs.readFileSync(DATA_PATH, "utf8");\n  return JSON.parse(raw);\n}\n\nfunction toTimestamp(event) {\n  // Combine date+time into a timestamp for consistent sorting\n  const iso = `${event.date}T${event.time}:00`;\n  return new Date(iso).getTime();\n}\n\nfunction parseNumber(v, def) {\n  const n = Number(v);\n  return Number.isFinite(n) ? n : def;\n}\n\nrouter.get("/", (req, res) => {\n  try {\n    const {\n      page = "1",\n      limit = "4",\n      sortBy = "date",\n      sortOrder = "desc",\n      date,\n      dateFrom,\n      dateTo,\n      time,\n      timeFrom,\n      timeTo,\n      type,\n      place,\n      minPopularity,\n      maxPopularity,\n    } = req.query;\n\n    let events = loadEvents();\n\n    // Filtering\n    events = events.filter((e) => {\n      // date exact\n      if (date && e.date !== String(date)) return false;\n\n      // date range\n      if (dateFrom && e.date < String(dateFrom)) return false;\n      if (dateTo && e.date > String(dateTo)) return false;\n\n      // time exact\n      if (time && e.time !== String(time)) return false;\n\n      // time range\n      if (timeFrom && e.time < String(timeFrom)) return false;\n      if (timeTo && e.time > String(timeTo)) return false;\n\n      // type contains (case-insensitive)\n      if (type && !e.type.toLowerCase().includes(String(type).toLowerCase())) return false;\n\n      // place contains (case-insensitive)\n      if (place && !e.place.toLowerCase().includes(String(place).toLowerCase())) return false;\n\n      const minPop = parseNumber(minPopularity, -Infinity);\n      const maxPop = parseNumber(maxPopularity, Infinity);\n      if (e.popularity < minPop) return false;\n      if (e.popularity > maxPop) return false;\n\n      return true;\n    });\n\n    // Sorting\n    const order = String(sortOrder).toLowerCase() === "asc" ? 1 : -1;\n    events.sort((a, b) => {\n      if (sortBy === "popularity") {\n        return (a.popularity - b.popularity) * order;\n      }\n      if (sortBy === "time") {\n        return (a.time.localeCompare(b.time)) * order;\n      }\n      // default: date (uses date + time timestamp)\n      const at = toTimestamp(a);\n      const bt = toTimestamp(b);\n      return (at - bt) * order;\n    });\n\n    // Pagination\n    const pageNum = Math.max(1, parseInt(page, 10) || 1);\n    const limitNum = Math.max(1, Math.min(100, parseInt(limit, 10) || 4));\n    const total = events.length;\n    const totalPages = Math.max(1, Math.ceil(total / limitNum));\n    const start = (pageNum - 1) * limitNum;\n    const end = start + limitNum;\n    const pageItems = events.slice(start, end);\n\n    res.json({\n      data: pageItems,\n      pagination: {\n        page: pageNum,\n        limit: limitNum,\n        total,\n        totalPages,\n        hasNextPage: end < total,\n      },\n      sort: { sortBy, sortOrder },\n      filters: { date, dateFrom, dateTo, time, timeFrom, timeTo, type, place, minPopularity, maxPopularity },\n    });\n  } catch (err) {\n    console.error("/api/events error:", err);\n    res.status(500).json({ error: "Failed to load events" });\n  }\n});\n\nmodule.exports = router;